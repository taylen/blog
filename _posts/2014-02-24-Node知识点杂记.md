---
layout: post
title: Node 知识点杂记
---

{{ page.title }}
=================

<p class="meta">24 Feb 2014 - Node 知识点杂记</p>

<p>
	<h2>
		第一章 Node简介
	</h2>
	1. 浏览器端V8与Webkit共用一个线程，当浏览器进行渲染的时候会影响JS的执行，同时JS的执行也会影响到Web的渲染；<br/>
	2. Node 具有单线程的特点，有利也有弊，可以通过child_process实现子进程；<br/>
	3. Node 对于Post请求可以通过res.on("data", function(trunk){})和res.on("end", function(){})接受数据；Get请求需要通过URL模块获取；当然对于Http的请求参数的操作，通过querystring模块进行处理非常方便；<br/>
	4. 相对于CPU密集型场景，Node更适合IO密集型Web应用，对于任务单一、并发性要求高的需求最为合适

</p>

<p>
	<h2>
		第二章 模块机制
	</h2>
	1. CommonJS简单的说就是：FS、TCP、Stream、Buffer...的一套规范，也是JS作为后端语言所缺少但又必须的功能模块，CommonJS与ECMAScript共同组成Node；<br/>
	2. Node模块可以分为两类：一类Node提供的模块，称为核心模块；另一类用户编写的模块，称为文件模块，核心模块优先于文件模块；<br/>
	3. 核心模块包含：JavaScript模块和C/C++内建模块，文件模块依赖于核心模块，核心模块依赖于内建模块
</p>

<p>
	<h2>
		第三章 异步I/O
	</h2>
	1. 异步IO和非阻塞IO的区别，非阻塞IO不带数据直接返回，要获取数据需要通过轮询手段读取，类似于C++的Server，而轮询方案中epoll是Linux下效率最高的IO时间通知机制，它真实利用了事件通知、执行回调的方式，而不是遍历查询。Nginx的事件机制也是通过epoll实现的。<br/>
	2. Node的单线程，仅仅是JS执行在单线程中，Node的内部完成IO任务的都另有线程池；<br/>
	3. 事件监听的实现大都基于观察者模式，通过时间循环向观察者询问是否有要处理的事件。事件循环是典型的生产者/消费者模型。<br/>
	4. setTimeout/setInterval/setImmediate/process.nextTick区别，定时器并非准确的（容忍范围内），由于没有sleep方法，所以只能通过这些定时器实现；setTimeout较为浪费性能，process.nextTick()相对较为轻量；process.nextTick()中回调函数的优先级高于setImmediate()，process.nextTick()属于idle观察者，setImmediate属于check观察者，轮询中，idle观察者先于I/O观察者，I/O观察者先于check观察者。<br/>
	5. 事件循环是异步实现的核心
</p>

<p>
	<h2>
		第四章 异步编程
	</h2>
	1. 异步编程涉及到回调函数，会导致函数嵌套过多，于是出现了很多代码编写模式；<br/>
	2. Promise/Deferred模式，最早出现于Dojo代码中，后来jQuery1.5开始支持，eg:
		<p style="white-space:pre-wrap;background-color:rgb(214, 235, 214);font-family:consolas;">
			$.get('/api', {
				success: onSuccess,
				error: onError,
				complete: onComplete
			});
			//Promise写法
			$.get("/api")
			 .success(onSuccess)
			 .error(onError)
			 .complete(onComplete);
		</p>
	3. Promise优势：减少嵌套，代码易读；实现同步<br/>
</p>

<p>
	<h2>
		第五章 内存控制
	</h2>
	1. V8引擎为浏览器设计，不太可能涉及到大量内存应用场景，所以默认64位默认1.4GB，32位默认0.7GB，当然可调整；<br/>
	2. V8的内存限制默认可以在50ms内自动回收，调整后对JS的执行会带来一定的影响；<br/>
	3. Node的内存分为：堆内内存和堆外内存，堆内内存主要是V8分配和管理；堆外内存主要是Node自行分配的部分（大都是C++自行分配和使用，可以突破内存限制问题，如Buffer）；<br/>
	4. 内存泄露主要原因：缓存、队列消费不及时、作用域未释放；<br/>
	5. 查看内存使用情况：process.memoryUsage(); {rss: "", heapTotal: "", heapUsed: ""} rss代表常驻内存部分，heapTotal为堆中共申请内存，heapUsed为堆中使用内存量；<br/>
	6. Node提供了Stream模块用于处理大文件，其提供了管道方法pipe()，不会受到V8内存限制，并提高了程序健壮性<br/>
</p>

<p>
	<h2>
		第六章 理解Buffer
	</h2>
	1. 中文字节在UTF-8编码下占用3个元素，字母和半角标点占用一个元素；<br/>
	2. Node以8KB来区分Buffer是大对象还是小对象，如果Buffer小于8KB，Node采用slab机制进行预申请和事后分配；对于大块Buffer直接使用C++层面的内存，无需细腻的分配操作；<br/>
	3. Buffer编码不支持GBK/GB2312/BIG-5，可以通过Buffer.isEncoding(encoding)判断哪种编码类型，还可以使用iconv-lite实现转码；<br/>
	4. 字符串和Buffer有实质上的差异，Buffer是二进制数据，字符串与Buffer存在编码关系<br/>
</p>

<p>
	<h2>
		第七章 网络编程
	</h2>
	1. Node是一个面向网络而生的平台，具有事件驱动、无阻塞、单线程等特点，具备良好的可伸缩性，Node提供了net/dgram/http/https这四个模块，分别用于处理TCP/UDP/HTTP/HTTPS，适用于服务器端和客户端；<br/>
	2. OSI模型7层：物理层、链路层、网络层(IP)、传输层(TCP/UDP)、会话层(通信连接/维持会话)、表示层(加密/解密等)、应用层(HTTP/SMTP/IMAP等)；<br/>
	3. TCP是面向连接的协议，3次握手形成会话，可以通过telnet模拟TCP请求，TCP默认启用Nagle算法；<br/>
	4. UDP即用户数据包协议，UDP不是面向连接的，提供面向事物的简单不可靠信息传输服务，如音频、视频等，包括DNS也是基于UDP实现的；<br/>
	5. HTTP全程超文本传输协议，是构建在TCP之上，属于应用层传输协议，在Node中HTTP服务器继承自TCP服务器（net模块）。从协议角度看，浏览器其实是一个HTTP的代理，处理HTTP请求，处理HTTP响应，服务器端也是如此，无论HTTP request或者response，报文内容都包含两个部分：报文头和报文体，可以通过curl工具可以查看具体的HTTP请求过程；<br/>
	6. HTTP请求及响应都是Key/Value格式；<br/>
	7. WebSocket客户端基于事件的变成模型与Node自定义事件相差无几，WebSocket实现的是建立在TCP上的长连接，可以双向通信；通过send和onmessage可以实现数据互传，基本现代浏览器都支持WebSocket；Node虽然没有内置WebSocket库，社区中有很多，包括socket.io；<br/>
	8. Node在网络安全上提供了三个模块：crypto/tls/https，其中crypto用于加密解密(包括SHA1、MD5)，tls模块是建立在TLS/SSL加密的TCP链接上，https同http一样，只是建立于安全的链接之上；<br/>
	9. TLS/SSL是一个公钥/私钥的结构，通过数字证书进行认证（CA：数字证书认证中心）；<br/>
	10. HTTPS就是工作在TLS/SSL上的HTTP<br/>
</p>

<p>
	后续敬请期待
</p>

本文摘自 朴灵《深入浅出NodeJS》

